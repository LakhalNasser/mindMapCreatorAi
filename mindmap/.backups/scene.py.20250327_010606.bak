from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from .models import Node, Connection
import math

class MindMapScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.setSceneRect(-2000, -2000, 4000, 4000)
        self.setBackgroundBrush(QColor("#FFFFFF"))
        self.node_spacing_x = 300  # زيادة المسافة الأفقية
        self.node_spacing_y = 200  # زيادة المسافة الرأسية
        self.root_node = None
        self.min_node_distance = 150  # الحد الأدنى للمسافة بين العقد

    def create_from_json(self, data):
        self.clear()
        self.root_node = Node(data['center'], 0)
        self.addItem(self.root_node)
        self.root_node.setPos(0, 0)
        
        if 'branches' in data:
            branches = data['branches']
            total_angle = 360  # توزيع كامل الدائرة
            angle_step = total_angle / len(branches)
            radius = 400  # نصف قطر التوزيع
            
            for i, branch_data in enumerate(branches):
                angle = math.radians(i * angle_step)
                self.create_branch(self.root_node, branch_data, angle, radius, 1)
        
        self.optimize_layout()
        self.update_all_connections()

    def create_branch(self, parent_node, branch_data, angle, radius, level):
        # إنشاء العقدة
        branch_node = Node(branch_data['text'], level)
        self.addItem(branch_node)
        
        # حساب الموقع باستخدام الإحداثيات القطبية
        x = parent_node.pos().x() + radius * math.cos(angle)
        y = parent_node.pos().y() + radius * math.sin(angle)
        branch_node.setPos(x, y)
        
        # إنشاء الاتصال
        connection = self.create_curved_connection(parent_node, branch_node)
        self.addItem(connection)
        
        # معالجة الفروع الفرعية
        if 'children' in branch_data and branch_data['children']:
            children = branch_data['children']
            child_angle_range = math.pi / 3  # نطاق زاوية الأطفال
            child_radius = radius * 0.6  # تقليل نصف القطر للمستوى التالي
            
            for i, child_data in enumerate(children):
                child_angle = angle - (child_angle_range/2) + (child_angle_range * (i+1)/(len(children)+1))
                self.create_branch(branch_node, child_data, child_angle, child_radius, level + 1)

    def optimize_layout(self):
        # تحسين تخطيط المخطط لتجنب التداخل
        iterations = 50
        for _ in range(iterations):
            moved = False
            for item1 in self.items():
                if not isinstance(item1, Node):
                    continue
                    
                for item2 in self.items():
                    if not isinstance(item2, Node) or item1 == item2:
                        continue
                        
                    pos1 = item1.pos()
                    pos2 = item2.pos()
                    dx = pos2.x() - pos1.x()
                    dy = pos2.y() - pos1.y()
                    distance = math.sqrt(dx*dx + dy*dy)
                    
                    if distance < self.min_node_distance:
                        # حساب قوة التنافر
                        force = (self.min_node_distance - distance) / distance
                        move_x = dx * force * 0.1
                        move_y = dy * force * 0.1
                        
                        # تحريك العقد بعيداً عن بعضها
                        if item1 != self.root_node:
                            item1.setPos(pos1.x() - move_x, pos1.y() - move_y)
                        if item2 != self.root_node:
                            item2.setPos(pos2.x() + move_x, pos2.y() + move_y)
                        moved = True
            
            if not moved:
                break

    def organize_branches(self, parent_node, branches_data, level=1):
        if not branches_data:
            return
            
        total_width = len(branches_data) * self.node_spacing_x
        start_x = -total_width / 2
        
        for i, branch_data in enumerate(branches_data):
            # إنشاء عقدة الفرع
            branch_node = Node(branch_data['text'], level)
            self.addItem(branch_node)
            
            # حساب الموقع
            x = start_x + (i * self.node_spacing_x)
            y = parent_node.pos().y() + self.node_spacing_y
            branch_node.setPos(x, y)
            
            # إنشاء الرابط
            connection = self.create_curved_connection(parent_node, branch_node)
            self.addItem(connection)
            
            # معالجة الفروع الفرعية
            if 'children' in branch_data and branch_data['children']:
                self.organize_children(branch_node, branch_data['children'], level + 1)

    def organize_children(self, parent_node, children_data, level):
        total_width = len(children_data) * (self.node_spacing_x * 0.8)  # تقليل المسافة للمستويات الأعمق
        start_x = parent_node.pos().x() - (total_width / 2)
        
        for i, child_data in enumerate(children_data):
            child_node = Node(child_data['text'], level)
            self.addItem(child_node)
            
            # حساب الموقع مع مراعاة موقع الأب
            x = start_x + (i * (self.node_spacing_x * 0.8))
            y = parent_node.pos().y() + self.node_spacing_y
            child_node.setPos(x, y)
            
            # إنشاء رابط منحني
            connection = self.create_curved_connection(parent_node, child_node)
            self.addItem(connection)
            
            # معالجة الأبناء بشكل متكرر
            if 'children' in child_data and child_data['children']:
                self.organize_children(child_node, child_data['children'], level + 1)

    def create_curved_connection(self, start_node, end_node):
        connection = Connection(start_node, end_node)
        
        # تحسين شكل المنحنى
        start_pos = start_node.pos()
        end_pos = end_node.pos()
        
        # حساب نقاط التحكم للمنحنى
        dx = end_pos.x() - start_pos.x()
        dy = end_pos.y() - start_pos.y()
        distance = math.sqrt(dx*dx + dy*dy)
        
        # تعديل نقاط التحكم بناءً على المسافة
        ctrl_distance = distance * 0.4
        angle = math.atan2(dy, dx)
        
        ctrl1 = QPointF(
            start_pos.x() + math.cos(angle) * ctrl_distance,
            start_pos.y() + math.sin(angle) * ctrl_distance
        )
        
        ctrl2 = QPointF(
            end_pos.x() - math.cos(angle) * ctrl_distance,
            end_pos.y() - math.sin(angle) * ctrl_distance
        )
        
        connection.setPath(self.create_smooth_path(start_pos, end_pos, ctrl1, ctrl2))
        return connection

 
    def update_all_connections(self):
        for item in self.items():
            if isinstance(item, Connection):
                start_pos = item.startNode.pos()
                end_pos = item.endNode.pos()
                
                # تحديث المسار المنحني
                dx = end_pos.x() - start_pos.x()
                dy = end_pos.y() - start_pos.y()
                distance = math.sqrt(dx*dx + dy*dy)
                
                ctrl_distance = distance * 0.4
                angle = math.atan2(dy, dx)
                
                ctrl1 = QPointF(
                    start_pos.x() + math.cos(angle) * ctrl_distance,
                    start_pos.y() + math.sin(angle) * ctrl_distance
                )
                
                ctrl2 = QPointF(
                    end_pos.x() - math.cos(angle) * ctrl_distance,
                    end_pos.y() - math.sin(angle) * ctrl_distance
                )
                
                item.setPath(self.create_smooth_path(start_pos, end_pos, ctrl1, ctrl2))

    def mousePressEvent(self, event):
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.scenePos(), QTransform())
            if isinstance(item, Node):
                # إضافة تأثير التحديد
                item.setSelected(True)
                item._hover_color = QColor("#FF5722")
                item.update()

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        for item in self.selectedItems():
            if isinstance(item, Node):
                item.setSelected(False)
                item._hover_color = QColor("#64B5F6")
                item.update()

    def wheelEvent(self, event):
        # تحسين التكبير/التصغير
        if event.modifiers() == Qt.ControlModifier:
            factor = 1.1 if event.delta() > 0 else 0.9
            view = self.views()[0]
            view.scale(factor, factor)
        else:
            super().wheelEvent(event)