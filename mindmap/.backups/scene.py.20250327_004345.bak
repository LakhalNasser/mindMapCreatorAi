from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from .models import Node, Connection
import math

class MindMapScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.setSceneRect(-2000, -2000, 4000, 4000)
        self.setBackgroundBrush(QColor("#FAFAFA"))
        
        # ثوابت التنسيق الموحدة
        self.VERTICAL_SPACING = 150    # المسافة الرأسية بين المستويات
        self.HORIZONTAL_SPACING = 200  # المسافة الأفقية الأساسية
        self.REGION_MARGIN = 40        # هامش المنطقة
        self.ROOT_Y = -500            # موقع الجذر
        self.LEVEL_SCALE = 0.8        # معامل تقليص المستويات
        
        self.nodes = []
        self.connections = []
        self.regions = {}
        self.root_node = None

    def create_from_json(self, data):
        self.clear()
        self.nodes = []
        self.connections = []
        self.regions = {}
        
        # إنشاء العقدة المركزية
        self.root_node = self.create_node(data['center'], 0)
        self.root_node.setPos(0, self.ROOT_Y)
        
        if 'branches' in data:
            self.organize_main_branches(self.root_node, data['branches'])
            self.create_and_adjust_regions()
            self.optimize_layout()
        
        self.center_on_root()
 
    def organize_main_branches(self, parent_node, branches_data):
        if not branches_data:
            return
            
        branch_count = len(branches_data)
        total_width = branch_count * self.HORIZONTAL_SPACING
        start_x = -total_width / 2
        
        for i, branch_data in enumerate(branches_data):
            x = start_x + (i * self.HORIZONTAL_SPACING)
            y = parent_node.pos().y() + self.VERTICAL_SPACING
            
            branch_node = self.create_node(branch_data['text'], 1)
            branch_node.setPos(x, y)
            self.create_connection(parent_node, branch_node)
            
            if 'children' in branch_data and branch_data['children']:
                self.organize_children_in_region(branch_node, branch_data['children'], 2)
                
    def organize_branch_children(self, parent_node, children_data, level=2):
        """تنظيم الأبناء حول العقدة الأب"""
        if not children_data:
            return
            
        child_count = len(children_data)
        spacing = self.HORIZONTAL_SPACING * (0.7 ** (level - 1))  # تقليل المسافة مع العمق
        total_width = child_count * spacing
        start_x = parent_node.pos().x() - (total_width / 2)
        y = parent_node.pos().y() + (self.VERTICAL_SPACING * 0.8)
        
        children_nodes = []
        for i, child_data in enumerate(children_data):
            x = start_x + (i * spacing)
            
            child_node = self.create_node(child_data['text'], level)
            child_node.setPos(x, y)
            children_nodes.append(child_node)
            
            self.create_connection(parent_node, child_node)
            
            # معالجة الأبناء بشكل متكرر
            if 'children' in child_data and child_data['children']:
                self.organize_branch_children(child_node, child_data['children'], level + 1)
        
        # تعديل مواقع الأبناء لتجنب التداخل
        self.adjust_children_positions(children_nodes)

    def create_and_adjust_regions(self):
        """إنشاء وتعديل مناطق العقد"""
        # إنشاء المناطق لكل العقد التي لديها أبناء
        for node in self.nodes:
            children = self.get_node_children(node)
            if children:
                region = self.calculate_region(node, children)
                self.regions[node] = region
        
        # تعديل المناطق لمنع التداخل
        self.adjust_overlapping_regions()

    def calculate_region(self, parent_node, children):
        """حساب المنطقة المحيطة بالعقدة وأبنائها"""
        all_nodes = [parent_node] + children
        all_descendants = []
        for child in children:
            all_descendants.extend(self.get_node_descendants(child))
        all_nodes.extend(all_descendants)
        
        # حساب حدود المنطقة
        left = min(node.pos().x() - node.boundingRect().width()/2 for node in all_nodes)
        right = max(node.pos().x() + node.boundingRect().width()/2 for node in all_nodes)
        top = min(node.pos().y() - node.boundingRect().height()/2 for node in all_nodes)
        bottom = max(node.pos().y() + node.boundingRect().height()/2 for node in all_nodes)
        
        # إضافة هامش
        margin = self.REGION_MARGIN
        return QRectF(left - margin, top - margin,
                     (right - left) + 2*margin,
                     (bottom - top) + 2*margin)
                    
    def create_node(self, text, level):
        node = Node(text, level)
        self.addItem(node)
        self.nodes.append(node)
        return node

    def create_connection(self, start_node, end_node):
        connection = Connection(start_node, end_node)
        self.addItem(connection)
        self.connections.append(connection)
        return connection

    def get_node_children(self, node):
        return [conn.endNode for conn in self.connections if conn.startNode == node]

    def get_node_descendants(self, node):
        descendants = []
        children = self.get_node_children(node)
        for child in children:
            descendants.append(child)
            descendants.extend(self.get_node_descendants(child))
        return descendants

    def organize_tree(self, parent_node, branches_data, level=1):
        if not branches_data:
            return
        
        # حساب العرض الكلي للمستوى
        level_width = len(branches_data) * (self.NODE_SPACING * (self.LEVEL_SCALE ** level))
        start_x = -level_width / 2
        spacing = self.NODE_SPACING * (self.LEVEL_SCALE ** level)
        
        nodes_at_level = []
        for i, branch_data in enumerate(branches_data):
            # إنشاء العقدة
            node = self.create_node(branch_data['text'], level)
            x = start_x + (i * spacing)
            y = parent_node.pos().y() + self.LEVEL_SPACING
            node.setPos(x, y)
            nodes_at_level.append(node)
            
            # إنشاء الرابط
            self.create_connection(parent_node, node)
            
            # معالجة الفروع الفرعية
            if 'children' in branch_data and branch_data['children']:
                self.organize_tree(node, branch_data['children'], level + 1)
        
        # تحسين توزيع العقد في نفس المستوى
        self.adjust_level_spacing(nodes_at_level)

    def adjust_level_spacing(self, nodes):
        if len(nodes) <= 1:
            return
            
        min_spacing = self.HORIZONTAL_SPACING * (self.LEVEL_SCALE ** nodes[0].level)
        
        for i in range(len(nodes) - 1):
            current = nodes[i]
            next_node = nodes[i + 1]
            actual_spacing = next_node.pos().x() - current.pos().x()
            
            if actual_spacing < min_spacing:
                shift = (min_spacing - actual_spacing) / 2
                self.shift_node_and_descendants(current, -shift, 0)
                self.shift_node_and_descendants(next_node, shift, 0)

    def organize_children_in_region(self, parent_node, children_data, level):
        """تنظيم الأبناء في منطقة حول العقدة الأب"""
        if not children_data:
            return
            
        child_count = len(children_data)
        region_width = self.HORIZONTAL_SPACING * (self.LEVEL_SCALE ** (level - 1))
        region_height = self.VERTICAL_SPACING * 0.8
        
        # توزيع الأبناء في مصفوفة
        cols = min(child_count, 3)  # الحد الأقصى 3 عقد في الصف
        rows = (child_count + cols - 1) // cols
        
        for i, child_data in enumerate(children_data):
            row = i // cols
            col = i % cols
            
            # حساب الموقع في المصفوفة
            x = parent_node.pos().x() + (col - (cols-1)/2) * region_width
            y = parent_node.pos().y() + (row + 1) * region_height
            
            child_node = self.create_node(child_data['text'], level)
            child_node.setPos(x, y)
            self.create_connection(parent_node, child_node)
            
            if 'children' in child_data and child_data['children']:
                self.organize_children_in_region(child_node, child_data['children'], level + 1)    

    def optimize_layout(self):
        """تحسين التخطيط النهائي"""
        self.update_all_connections()
        self.remove_overlaps()

    def adjust_node_positions(self):
        """تعديل مواقع العقد لتحسين التوزيع"""
        for level in range(5, -1, -1):
            level_nodes = [node for node in self.nodes if node.level == level]
            if len(level_nodes) > 1:
                self.adjust_level_nodes(level_nodes)

    def adjust_level_nodes(self, nodes):
        """تعديل مواقع العقد في نفس المستوى"""
        min_spacing = self.NODE_SPACING * (0.8 ** nodes[0].level)
        
        # فرز العقد حسب الموقع الأفقي
        nodes.sort(key=lambda n: n.pos().x())
        
        # تعديل المسافات
        for i in range(len(nodes) - 1):
            current = nodes[i]
            next_node = nodes[i + 1]
            actual_spacing = next_node.pos().x() - current.pos().x()
            
            if actual_spacing < min_spacing:
                shift = (min_spacing - actual_spacing) / 2
                self.shift_subtree(current, -shift)
                self.shift_subtree(next_node, shift)

    def shift_subtree(self, root_node, dx):
        """تحريك العقدة وجميع أبنائها"""
        root_node.setPos(root_node.pos().x() + dx, root_node.pos().y())
        children = self.get_node_children(root_node)
        for child in children:
            self.shift_subtree(child, dx)

    def adjust_regions(self):
        """تعديل مواقع المناطق لمنع التداخل"""
        for node1, region1 in self.regions.items():
            for node2, region2 in self.regions.items():
                if node1 != node2 and region1.intersects(region2):
                    # حساب وتطبيق الإزاحة اللازمة
                    self.adjust_overlapping_regions(node1, node2)

    def get_node_children(self, node):
        """الحصول على الأبناء المباشرين للعقدة"""
        return [conn.endNode for conn in self.connections if conn.startNode == node]
 
    def adjust_overlapping_regions(self):
        """معالجة تداخل المناطق"""
        changed = True
        while changed:
            changed = False
            for node1, region1 in self.regions.items():
                for node2, region2 in self.regions.items():
                    if node1 != node2 and region1.intersects(region2):
                        # حساب وتطبيق الإزاحة
                        self.resolve_region_overlap(node1, node2)
                        changed = True
                        # تحديث المناطق
                        self.regions[node1] = self.calculate_region(
                            node1, self.get_node_children(node1))
                        self.regions[node2] = self.calculate_region(
                            node2, self.get_node_children(node2))

    def resolve_region_overlap(self, node1, node2):
        """معالجة تداخل منطقتين"""
        # حساب اتجاه الإزاحة
        dx = node2.pos().x() - node1.pos().x()
        dy = node2.pos().y() - node1.pos().y()
        
        # تحديد اتجاه الإزاحة الأفضل
        if abs(dx) > abs(dy):
            shift_x = (self.HORIZONTAL_SPACING/2) * (1 if dx > 0 else -1)
            self.shift_node_and_descendants(node1, -shift_x, 0)
            self.shift_node_and_descendants(node2, shift_x, 0)
        else:
            shift_y = (self.VERTICAL_SPACING/2) * (1 if dy > 0 else -1)
            self.shift_node_and_descendants(node1, 0, -shift_y)
            self.shift_node_and_descendants(node2, 0, shift_y)

    def shift_node_and_descendants(self, node, dx, dy):
        """تحريك العقدة وجميع أبنائها"""
        node.setPos(node.pos().x() + dx, node.pos().y() + dy)
        for descendant in self.get_node_descendants(node):
            descendant.setPos(descendant.pos().x() + dx, descendant.pos().y() + dy)

    def adjust_children_positions(self, children):
        """تعديل مواقع الأبناء لتجنب التداخل"""
        if len(children) <= 1:
            return
            
        min_spacing = self.HORIZONTAL_SPACING * (0.7 ** children[0].level)
        
        # فحص وتصحيح التداخلات
        for i in range(len(children) - 1):
            current = children[i]
            next_node = children[i + 1]
            
            actual_spacing = next_node.pos().x() - current.pos().x()
            if actual_spacing < min_spacing:
                shift = (min_spacing - actual_spacing) / 2
                self.shift_node_and_descendants(current, -shift, 0)
                self.shift_node_and_descendants(next_node, shift, 0)

    def move_node_and_children(self, node, dx, dy):
        """تحريك العقدة وجميع أبنائها"""
        node.setPos(node.pos().x() + dx, node.pos().y() + dy)
        for child in self.get_node_descendants(node):
            child.setPos(child.pos().x() + dx, child.pos().y() + dy)

    def remove_overlaps(self):
        """إزالة التداخلات بين العقد"""
        changed = True
        while changed:
            changed = False
            for node1 in self.nodes:
                for node2 in self.nodes:
                    if node1 != node2 and self.nodes_overlap(node1, node2):
                        self.resolve_overlap(node1, node2)
                        changed = True

    def nodes_overlap(self, node1, node2):
        """التحقق من تداخل العقد"""
        rect1 = node1.sceneBoundingRect()
        rect2 = node2.sceneBoundingRect()
        return rect1.intersects(rect2)

    def resolve_overlap(self, node1, node2):
        """معالجة التداخل بين العقد"""
        rect1 = node1.sceneBoundingRect()
        rect2 = node2.sceneBoundingRect()
        
        # حساب مقدار التداخل
        dx = (rect1.center().x() - rect2.center().x()) / 2
        dy = (rect1.center().y() - rect2.center().y()) / 2
        
        # تحريك العقد في الاتجاه المعاكس
        self.shift_subtree(node1, dx)
        self.shift_subtree(node2, -dx)

    def balance_groups(self):
        """موازنة المجموعات أفقياً"""
        for level in range(5):
            level_nodes = [node for node in self.nodes if node.level == level]
            if level_nodes:
                avg_x = sum(node.pos().x() for node in level_nodes) / len(level_nodes)
                for node in level_nodes:
                    current_x = node.pos().x()
                    new_x = current_x + (avg_x - current_x) * 0.3
                    node.setPos(new_x, node.pos().y())

    def update_all_connections(self):
        for connection in self.connections:
            connection.updatePosition()

    def center_on_root(self):
        if self.views() and self.root_node:
            view = self.views()[0]
            view.centerOn(self.root_node)
            view.scale(0.7, 0.7)
  
    def mousePressEvent(self, event):
        """معالجة النقر على العقد"""
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.scenePos(), QTransform())
            if isinstance(item, Node):
                self.highlight_connected_nodes(item)

    def highlight_connected_nodes(self, node):
        """إبراز العقد المتصلة"""
        for item in self.items():
            if isinstance(item, Node):
                item._is_highlighted = False
                item.update()
        
        node._is_highlighted = True
        for connection in self.connections:
            if connection.startNode == node:
                connection.endNode._is_highlighted = True
                connection.endNode.update()
            elif connection.endNode == node:
                connection.startNode._is_highlighted = True
                connection.startNode.update()
        
        node.update()