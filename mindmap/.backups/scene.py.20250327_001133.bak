from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from .models import Node, Connection
import math


class MindMapScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.setSceneRect(-2000, -2000, 4000, 4000)
        self.setBackgroundBrush(QColor("#FAFAFA"))
        
        # ثوابت التنسيق
        self.BASE_RADIUS = 300        # نصف قطر الدائرة الأساسية
        self.CHILD_RADIUS = 200       # نصف قطر دوائر الأبناء
        self.LEVEL_SCALE = 0.7        # معامل تقليص المستويات
        self.ANGLE_SPREAD = 360       # توزيع زاوي كامل
        self.ROOT_Y = -500            # موقع الجذر
        
        self.nodes = []
        self.connections = []
        self.root_node = None
        self.regions = {}             # مناطق كل رأس


    def clear(self):
        super().clear()
        self.nodes = []
        self.connections = []
        self.root_node = None

    def create_from_json(self, data):
        self.clear()
        self.nodes = []
        self.connections = []
        self.regions = {}
        
        # إنشاء العقدة المركزية
        self.root_node = self.create_node(data['center'], 0)
        self.root_node.setPos(0, self.ROOT_Y)
        
        if 'branches' in data:
            # توزيع الفروع الرئيسية في دائرة
            self.organize_circular_branches(self.root_node, data['branches'])
        
        self.create_regions()
        self.optimize_layout()
        self.center_on_root()

    def organize_circular_branches(self, parent_node, branches_data, level=1, start_angle=0, angle_span=360):
        if not branches_data:
            return
            
        count = len(branches_data)
        angle_step = angle_span / count
        radius = self.BASE_RADIUS * (self.LEVEL_SCALE ** (level - 1))
        
        for i, branch_data in enumerate(branches_data):
            # حساب موقع العقدة على الدائرة
            current_angle = math.radians(start_angle + (i * angle_step))
            x = parent_node.pos().x() + radius * math.cos(current_angle)
            y = parent_node.pos().y() + radius * math.sin(current_angle)
            
            # إنشاء العقدة
            node = self.create_node(branch_data['text'], level)
            node.setPos(x, y)
            
            # إنشاء الرابط
            connection = self.create_connection(parent_node, node)
            
            # تنظيم الأبناء في دائرة حول الأب
            if 'children' in branch_data and branch_data['children']:
                child_angle = math.degrees(current_angle)
                self.organize_children_around_parent(
                    node, 
                    branch_data['children'],
                    level + 1,
                    child_angle
                )

    def organize_children_around_parent(self, parent_node, children_data, level, base_angle):
        if not children_data:
            return
            
        count = len(children_data)
        # توزيع الأبناء في نصف دائرة باتجاه الخارج
        angle_span = min(180, 360 / (level + 1))
        start_angle = base_angle - (angle_span / 2)
        angle_step = angle_span / count
        radius = self.CHILD_RADIUS * (self.LEVEL_SCALE ** (level - 1))
        
        for i, child_data in enumerate(children_data):
            current_angle = math.radians(start_angle + (i * angle_step))
            x = parent_node.pos().x() + radius * math.cos(current_angle)
            y = parent_node.pos().y() + radius * math.sin(current_angle)
            
            node = self.create_node(child_data['text'], level)
            node.setPos(x, y)
            
            connection = self.create_connection(parent_node, node)
            
            if 'children' in child_data and child_data['children']:
                child_angle = math.degrees(current_angle)
                self.organize_children_around_parent(
                    node,
                    child_data['children'],
                    level + 1,
                    child_angle
                )

    def create_regions(self):
        """إنشاء مناطق منفصلة لكل رأس وأبنائه"""
        for node in self.nodes:
            if node.level <= 1:  # إنشاء مناطق للرؤوس الرئيسية فقط
                region = self.calculate_node_region(node)
                self.regions[node] = region

    def calculate_node_region(self, node):
        """حساب المنطقة التي يشغلها الرأس وأبناؤه"""
        children = self.get_node_descendants(node)
        if not children:
            return node.sceneBoundingRect()
        
        # حساب المستطيل المحيط بالرأس وجميع أبنائه
        all_nodes = [node] + children
        left = min(n.pos().x() for n in all_nodes)
        right = max(n.pos().x() for n in all_nodes)
        top = min(n.pos().y() for n in all_nodes)
        bottom = max(n.pos().y() for n in all_nodes)
        
        # إضافة هامش للمنطقة
        margin = 50
        return QRectF(left - margin, top - margin, 
                     (right - left) + 2*margin, 
                     (bottom - top) + 2*margin)

    def split_into_groups(self, branches_data):
        """تقسيم الفروع إلى مجموعات متوازنة"""
        groups = []
        current_group = []
        
        for branch in branches_data:
            current_group.append(branch)
            if len(current_group) >= self.MAX_NODES_PER_LEVEL:
                groups.append(current_group)
                current_group = []
        
        if current_group:
            groups.append(current_group)
        
        return groups

    def create_node(self, text, level):
        node = Node(text, level)
        self.addItem(node)
        self.nodes.append(node)
        return node

    def create_connection(self, start_node, end_node):
        connection = Connection(start_node, end_node)
        self.addItem(connection)
        self.connections.append(connection)
        return connection

    def get_node_descendants(self, node):
        """الحصول على جميع أبناء العقدة"""
        descendants = []
        for conn in self.connections:
            if conn.startNode == node:
                descendants.append(conn.endNode)
                descendants.extend(self.get_node_descendants(conn.endNode))
        return descendants

    def organize_tree(self, parent_node, branches_data, level=1):
        if not branches_data:
            return
        
        # حساب العرض الكلي للمستوى
        level_width = len(branches_data) * (self.NODE_SPACING * (self.LEVEL_SCALE ** level))
        start_x = -level_width / 2
        spacing = self.NODE_SPACING * (self.LEVEL_SCALE ** level)
        
        nodes_at_level = []
        for i, branch_data in enumerate(branches_data):
            # إنشاء العقدة
            node = self.create_node(branch_data['text'], level)
            x = start_x + (i * spacing)
            y = parent_node.pos().y() + self.LEVEL_SPACING
            node.setPos(x, y)
            nodes_at_level.append(node)
            
            # إنشاء الرابط
            self.create_connection(parent_node, node)
            
            # معالجة الفروع الفرعية
            if 'children' in branch_data and branch_data['children']:
                self.organize_tree(node, branch_data['children'], level + 1)
        
        # تحسين توزيع العقد في نفس المستوى
        self.adjust_level_spacing(nodes_at_level)

    def adjust_level_spacing(self, nodes):
        """تحسين المسافات بين العقد في نفس المستوى"""
        if len(nodes) <= 1:
            return
            
        min_spacing = self.NODE_SPACING * (self.LEVEL_SCALE ** nodes[0].level)
        
        # حساب وتصحيح التداخلات
        for i in range(len(nodes) - 1):
            current = nodes[i]
            next_node = nodes[i + 1]
            actual_spacing = next_node.pos().x() - current.pos().x()
            
            if actual_spacing < min_spacing:
                shift = (min_spacing - actual_spacing) / 2
                current.setPos(current.pos().x() - shift, current.pos().y())
                next_node.setPos(next_node.pos().x() + shift, next_node.pos().y())

    def optimize_layout(self):
        """تحسين التخطيط العام"""
        self.adjust_regions()
        self.update_all_connections()

    def adjust_regions(self):
        """تعديل مواقع المناطق لمنع التداخل"""
        for node1, region1 in self.regions.items():
            for node2, region2 in self.regions.items():
                if node1 != node2 and region1.intersects(region2):
                    # حساب وتطبيق الإزاحة اللازمة
                    self.adjust_overlapping_regions(node1, node2)

    def adjust_overlapping_regions(self, node1, node2):
        """معالجة تداخل المناطق"""
        pos1 = node1.pos()
        pos2 = node2.pos()
        
        # حساب اتجاه الإزاحة
        angle = math.atan2(pos2.y() - pos1.y(), pos2.x() - pos1.x())
        distance = 100  # مسافة الإزاحة
        
        # تحريك المنطقة الثانية
        dx = distance * math.cos(angle)
        dy = distance * math.sin(angle)
        self.move_node_and_children(node2, dx, dy)

    def move_node_and_children(self, node, dx, dy):
        """تحريك العقدة وجميع أبنائها"""
        node.setPos(node.pos().x() + dx, node.pos().y() + dy)
        for child in self.get_node_descendants(node):
            child.setPos(child.pos().x() + dx, child.pos().y() + dy)
            
    def remove_overlaps(self):
        """إزالة التداخلات بين العقد"""
        for node in self.nodes:
            for other in self.nodes:
                if node != other and abs(node.pos().y() - other.pos().y()) < 50:
                    if abs(node.pos().x() - other.pos().x()) < 150:
                        # تحريك العقد المتداخلة عمودياً
                        shift = 60
                        if node.pos().y() < other.pos().y():
                            other.setPos(other.pos().x(), other.pos().y() + shift)
                        else:
                            node.setPos(node.pos().x(), node.pos().y() + shift)

    def balance_groups(self):
        """موازنة المجموعات أفقياً"""
        for level in range(5):
            level_nodes = [node for node in self.nodes if node.level == level]
            if level_nodes:
                avg_x = sum(node.pos().x() for node in level_nodes) / len(level_nodes)
                for node in level_nodes:
                    current_x = node.pos().x()
                    new_x = current_x + (avg_x - current_x) * 0.3
                    node.setPos(new_x, node.pos().y())

    def update_all_connections(self):
        for connection in self.connections:
            connection.updatePosition()

    def center_on_root(self):
        if self.views() and self.root_node:
            view = self.views()[0]
            view.centerOn(self.root_node)
            view.scale(0.7, 0.7)
   
    def mousePressEvent(self, event):
        """معالجة النقر على العقد"""
        super().mousePressEvent(event)
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.scenePos(), QTransform())
            if isinstance(item, Node):
                self.highlight_connected_nodes(item)

    def highlight_connected_nodes(self, node):
        """إبراز العقد المتصلة"""
        for item in self.items():
            if isinstance(item, Node):
                item._is_highlighted = False
                item.update()
        
        node._is_highlighted = True
        for connection in self.connections:
            if connection.startNode == node:
                connection.endNode._is_highlighted = True
                connection.endNode.update()
            elif connection.endNode == node:
                connection.startNode._is_highlighted = True
                connection.startNode.update()
        
        node.update()